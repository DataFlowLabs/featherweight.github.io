---
layout: docs
title: Design Philosophy
permalink: /philosophy/
authors:
  - Jack R. Dunaway
editors:
  - placeholder
---

Featherweight is two things: a design philosophy,
and a framework implementing this philosophy in a
graphical programming language.


"Featherweight" is also a design principle for maximizing semantic-per-syntax
for application code, since lots of syntax is generally a liability more than an
asset.

## Code

No Code is Better than No Code.â„¢

Said another way, there does not exist a bit of code
that is better that no code, given the same observable result.

Given two implementations of an application, where the
end-users of the application are unable to perceive or
detect differences in features, performance, 

Software deliverables effectively have two sides. The outside
and the inside.

## Sides

Software has only two sides.

The inside, and the outside.

#### The Outside

An end-user, beneficiary, stakeholder or otherwise observer of
deployed software experiences its existence. Perhaps by inputting
information; and perhaps by being influenced by its output.

Software may interact with more than just humans, but <em>Featherweight
specifically seeks to characterize and optimize observable delight in
humans.</em>

#### The Inside

Developers see. Code. Processes. Design patterns. Deployment.


#### The Dividing Line


#### FTW has an Outside and an Inside

Featherweight is software for software developers. This gets a bit
meta, attempting to optimize for either its end-users or its
developers (where, a FTW developer is also an end-user).

Additionally, FTW is used to make software that likewise has an
inside and an outside. Choosing to use FTW in an application 

This is a gross simplification of the many facets and nuanced
interactions between developers and end-users; yet, as developers
ourselves, we like such simple models in order to characterize
and debug.

## Codebase

Your codebase is both an asset and a liability.

## Maximal Semantic-per-Syntax

Syntax is an incidental complexity for conveying semantic,
and generally, making things happen.

The less syntax the better.

## Failure

Failure happens. Embrace this. Create robust systems with fail-safe
defaults that aggressively defend their ability to perform their job.

## Complexity

Complexity exists. 